/*
 * Remote Sim Lock API
 *
 * **Implementation of the Remote Sim Lock APIs**  **Vibe project documentation (including RSL) can be found using the following links:**     **1- DRAFT-RSL sequence flows pictures source ZY-20220225.docx**    * https://kaios.sharepoint.com/:w:/r/sites/vibe/Shared%20Documents/4.%20PRODUCT/06%20-%20RSL%20REQ%20and%20Designing/DRAFT-RSL%20sequence%20flows%20pictures%20source%20ZY-20220225.docx?d=w8cba978f89bc4cac8460d87c0e1053ba&csf=1&web=1&e=iQp9Eo *    This document includes squence diagrams which describe the use cases: “device initiate” , “daily ping”, and “user change SIM to another one”.    **2- DRAFT-Vibe Remote SIM Lock Operation Structure-20220307.docx**    * https://kaios.sharepoint.com/:w:/r/sites/vibe/Shared%20Documents/4.%20PRODUCT/06%20-%20RSL%20REQ%20and%20Designing/DRAFT-Vibe%20Remote%20SIM%20Lock%20Operation%20Structure-20220307.docx?d=w51d49ceb6ddc4329aaa18ce02ce22318&csf=1&web=1&e=orUFfm    This is a short document which includes an introduction to the RSL operation structure, and RSL portal.    **3- RSL flow charts for communicate.v0.2.docx**    * https://kaios.sharepoint.com/:w:/r/sites/vibe/Shared%20Documents/4.%20PRODUCT/06%20-%20RSL%20REQ%20and%20Designing/RSL%20flow%20charts%20for%20communicate.v0.2.docx?d=w8215af326530486ab8b84b14e3208967&csf=1&web=1&e=H2DhdF    **4- Vibe RSL Technical Keypoints.20220915.pptx**    * https://kaios.sharepoint.com/:p:/r/sites/vibe/Shared%20Documents/4.%20PRODUCT/06%20-%20RSL%20REQ%20and%20Designing/Vibe%20RSL%20Technical%20Keypoints%20.20220915.pptx?d=w58603c5ed4814c9086a799450262b97e&csf=1&web=1&e=czrBNc    **5- Vibe Product requirement_211118.pptx**    * https://kaios-my.sharepoint.com/:p:/r/personal/raffi_semerciyan_kaiostech_com/Documents/Documents/20211124-Vibe/Vibe%20Product%20Requirement_211118.pptx?d=w130eb4dd2a74481d93cb1fec26c0d068&csf=1&web=1&e=ivj2jW    **6- Vibe-Requirements-Analysis.docx**    * https://kaios-my.sharepoint.com/:w:/g/personal/raffi_semerciyan_kaiostech_com/EXlVgqdcF7pAii8-VIHeRXQB_VQEBIbjO_2aU3Ur_Rqk1w?e=R7eaOb     This document shows the detailed design of RSL function, after making a requirement summary.      **7- Vibe-Specification.docx**   * https://kaios-my.sharepoint.com/:w:/g/personal/raffi_semerciyan_kaiostech_com/EXlVgqdcF7pAii8-VIHeRXQB_VQEBIbjO_2aU3Ur_Rqk1w?e=R7eaOb    This document shows the detailed use case diagrams which show the interaction between Vive users and the system.
 *
 * API version: 1.0.0
 * Contact: maen.hammour@kaiostech.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"runtime/pprof"
	"syscall"
	"time"

	"git.kaiostech.com/cloud/kc_rslbe/kc_rslbe_fe3/router"
	l4g "git.kaiostech.com/cloud/thirdparty/code.google.com/p/log4go"

	"git.kaiostech.com/cloud/common/config"

	"git.kaiostech.com/cloud/common/db/redisdb"
	"git.kaiostech.com/cloud/common/healthcheck"
	"git.kaiostech.com/cloud/common/mq"
	"git.kaiostech.com/cloud/common/security/credkey"
	"git.kaiostech.com/cloud/common/security/hawk"
	"git.kaiostech.com/cloud/common/security/jwttoken"
	"git.kaiostech.com/cloud/common/security/nonce"
	"git.kaiostech.com/cloud/common/security/ratelimit"
	"git.kaiostech.com/cloud/common/security/session"
	"git.kaiostech.com/cloud/common/security/token_blacklist"
	"git.kaiostech.com/cloud/common/utils/handlers_common"
	"git.kaiostech.com/cloud/common/utils/health_check"
)

var (
	_conf          *config.FEConfig
	_ca_cert_pool  *x509.CertPool
	_cypher_suites []uint16
	_tls_ca        []tls.Certificate

	// Used for graceful shutdown
	c_kill chan os.Signal
	c_int  chan os.Signal
	c_usr1 chan os.Signal

	https_server *http.Server
	http_server  *http.Server
)

const (
	FILE_SIGN        = 0x40
	SHUTDOWN_TIMEOUT = 10
)

func init() {
	c_kill = make(chan os.Signal, 1)
	c_int = make(chan os.Signal, 1)
	c_usr1 = make(chan os.Signal, 1)

}

func health_check_callback() {
	// Set any local statistics or state here.
	// Example:
	//health_check.Set_Statistic("Callback", "100", "number", "Test of callback function")
}

func Init() error {
	var err error

	if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
		health_check.Set_Status("Startup", "Init")
	}
	mq.Init(_conf.QueueService.FlushTimeOut, _conf.QueueService.MaxMsgSize, _conf.QueueService.RetryNb, _conf.QueueService.FERspTimeOut, _conf.Common.Debug, _conf)

	// This is not a mistake, we use LL2DL subject for the fe2dl channel because we don't want
	// to multiply the number of subjects DL should be listening to.
	handlers_common.Init(_conf.QueueService.Nodes, _conf.QueueService.FE2LL_Subject)

	if err = redisdb.Init(_conf.Common.Debug); err != nil {
		return errors.New(fmt.Sprintf("RedisDB error - %s", err))
	}

	if err = session.Init(_conf.RedisService.Nodes, _conf.RedisService.MaxRedirects); err != nil {
		return errors.New(fmt.Sprintf("RedisDB Session error - %s", err))
	}

	if err = credkey.Init(_conf.RedisService.Nodes, _conf.RedisService.MaxRedirects); err != nil {
		return errors.New(fmt.Sprintf("CredKey error - %s", err))
	}
	if err = nonce.Init(_conf.RedisService.Nodes, _conf.RedisService.MaxRedirects); err != nil {
		return errors.New(fmt.Sprintf("Nonce error - %s", err))
	}

	if err = ratelimit.Init(_conf.RedisService.Nodes, _conf.RedisService.MaxRedirects); err != nil {
		return errors.New(fmt.Sprintf("RateLimit error - %s", err))
	}

	if err = jwttoken.Init(_conf); err != nil {
		return errors.New(fmt.Sprintf("JWTToken error - %s", err))
	}

	if err = token_blacklist.Init(_conf.RedisService.Nodes, _conf.RedisService.MaxRedirects); err != nil {
		return errors.New(fmt.Sprintf("Token BlackList Init error - %s", err))
	}

	hawk.Init(_conf.Common.Debug)

	if _conf.FrontLayer.HttpPort != 0 {
		healthcheck.InitHttpHealthCheck()
	}

	return nil
}

func load_ca_root(conf *config.FEConfig) error {

	_ca_cert_pool = x509.NewCertPool()

	n_root_ca := len(conf.FrontLayer.RootCA)

	for i := 0; i < n_root_ca; i++ {
		// Load CA cert
		ca, err := ioutil.ReadFile(conf.FrontLayer.RootCA[i])
		if err != nil {
			l4g.Error(err)
			return err
		} else {
			_ca_cert_pool.AppendCertsFromPEM(ca)
		}
	}

	return nil
}

func load_tls(conf *config.FEConfig) error {
	var err error
	n_cert := len(conf.FrontLayer.CertX509File)
	n_key := len(conf.FrontLayer.CertKeyFile)

	if n_cert != n_key {
		msg := fmt.Sprintf("Amount of Certificates %d doesn't match number of keys %d. Aborting ...", n_cert, n_key)
		l4g.Error(msg)
		log.Fatalln(msg)
		return errors.New(msg)
	}

	_tls_ca = make([]tls.Certificate, n_cert)

	for i := 0; i < n_cert; i++ {

		_tls_ca[i], err = tls.LoadX509KeyPair(conf.FrontLayer.CertX509File[i], conf.FrontLayer.CertKeyFile[i])
		if err != nil {
			msg := "Failed to load Certificate/Key pair: " + err.Error() + ". Aborting ..."
			l4g.Error(msg)
			log.Fatalln(msg)
			return errors.New(msg)
		}
	}

	return nil
}

func load_cypher_suites(conf *config.FEConfig) error {
	// According to http://security.stackexchange.com/questions/76993/now-that-it-is-2015-what-ssl-tls-cipher-suites-should-be-used-in-a-high-securit
	// Here are the cyphers we should only accept
	_cypher_suites = []uint16{
		// TLS 1.2 AEAD only (all are SHA-2 as well)
		//tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
		//tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 ,
		//tls.TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 ,
		tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
		//tls.TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
		//tls.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
		tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,

		// TLS 1.2 SHA2 family
		//tls.TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
		//tls.TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
		//tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
		//tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
		//tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
		//tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,

		// Not supported by Go native library.
		//tls.TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384,
		//tls.TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
		//tls.TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,

		// Below is only useful for modern browsers that don't
		// have AEAD cipher suites like IE 11 and Safari 6 and 7
		// can use a few of these.
		//tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,

		tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,

		// Not recommended to support
		// tls.TLS_RSA_WITH_AES_256_GCM_SHA384,

	}

	return nil
}

var (
	opt_version *bool   = flag.Bool("version", false, "Display current tool version and exit.")
	config_file *string = flag.String("config", "conf/kc_fin_fe.conf", "Config file to use.")
	log_file    *string = flag.String("log", "conf/kc_rslbe_fe3_log.xml", "Log L4G config file to use.")
	key_file    *string = flag.String("key_file", "keys.json", "Keys used to boostrap fe node.")

	print_conf *bool = flag.Bool("print-conf", false, "Print current active configuration and exit.")

	cpu_prof = flag.String("cpu-prof", "", "write cpu profile to `file`")
	mem_prof = flag.String("mem-prof", "", "write memory profile to `file`")
)

func main() {
	var err error

	// Allow l4g to flush its content into the log file before terminating.
	defer time.Sleep(time.Second * 2)

	flag.Parse()

	if *cpu_prof != "" {
		f, err := os.Create(*cpu_prof)
		if err != nil {
			panic(fmt.Sprintf("could not create CPU profile: '%s'", err))
		}
		defer f.Close()
		if err := pprof.StartCPUProfile(f); err != nil {
			panic(fmt.Sprintf("could not start CPU profile: '%s'", err))
		}
		defer pprof.StopCPUProfile()
	}

	if *mem_prof != "" {
		f, err := os.Create(*mem_prof)
		if err != nil {
			panic(fmt.Sprintf("could not create memory profile: '%s'", err))
		}
		defer f.Close()
		runtime.GC() // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			panic(fmt.Sprintf("could not write memory profile: '%s'", err))
		}
	}

	if *opt_version {
		os.Exit(0)
	}

	l4g.LoadConfiguration(*log_file)
	l4g.Info("Here 2 Now opening configuration file:", *config_file)
	if file, err := os.OpenFile(*config_file, os.O_RDONLY, 0666); err == nil {

		_conf, err = config.Load_FEConfig(*config_file, *key_file)

		if err == nil {
			l4g.Info("Read config from '%s' ...", *config_file)
		} else {
			l4g.Warn("Failed to Read config from '%s': '%s'.", *config_file, err)
		}
		file.Close()
	}

	// Making sure to have the latest configuration.
	_conf = config.GetFEConfig()

	if *print_conf {
		fmt.Printf(config.GetFEConfig().String())
		os.Exit(0)
	}

	err = Init()

	if err != nil {
		fmt.Printf("Error during initialization: '%s'! Aborting ...", err)
		return
	}

	l4g.Info("Daemon Server initialized ...")

	if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
		health_check.Set_Status("Startup", "starting services")
	}

	signal.Notify(c_kill, syscall.SIGTERM)
	signal.Notify(c_int, syscall.SIGINT)
	signal.Notify(c_usr1, syscall.SIGUSR1)

	l4g.Info("Starting services for namespace %s...", config.GetFEConfig().RedisService.Table_Prefix)

	err_chan := start_servers(config.GetFEConfig())

	if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
		health_check.Set_Status("Up", "started successfully")
	}

main_loop:
	for {
		select {
		case <-c_kill:
			if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
				health_check.Set_Status("Shutdown", "SIGTERM received")
			}
			l4g.Info("SIGTERM signal received! Graceful shutdown initiated ...")
			stop_servers(config.GetFEConfig())
			break main_loop

		case <-c_int:
			if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
				health_check.Set_Status("Shutdown", "SIGINT received")
			}
			l4g.Info("SIGINT (Ctrl+c) detected! Graceful shutdown initiated ...")
			stop_servers(config.GetFEConfig())
			break main_loop

		case err = <-err_chan:
			fmt.Printf("[FATAL] Critical failure: %v\n", err)
			if _conf.FrontLayer.HealthCheck.HealthCheckEnable {
				health_check.Set_Status("Shutdown", "server error")
			}
			l4g.Error("Server graceful shutdown due to error '%s'", err.Error())
			stop_servers(config.GetFEConfig())
			break main_loop

		case <-c_usr1:
			l4g.LoadConfiguration(*log_file)
			l4g.Info("Reread L4G configuration file on reception of SIGUSR1 signal!")
		}
	}

	l4g.Info("Daemon graceful server shutdown completed")
	l4g.Close()
}

func stop_servers(conf *config.FEConfig) {

	time.Sleep(time.Second * 1)

	if conf.FrontLayer.HttpPort != 0 && conf.FrontLayer.HttpsPort != 0 {
		stop_http(conf)
		stop_https(conf)
	} else {

		if conf.FrontLayer.HttpPort != 0 {
			stop_http(conf)
		}

		if conf.FrontLayer.HttpsPort != 0 {
			stop_https(conf)
		}
	}
	if _conf.FrontLayer.HttpPort != 0 {
		healthcheck.StopHttpHealthCheck()
	}
}

/*
   This function may start 2 servers: one with HTTP and one with HTTPS depending
   on the provided configuration. Eventually, HTTP may be redirected to HTTPS.
*/
func start_servers(conf *config.FEConfig) chan error {

	errs := make(chan error, 1)

	if conf.FrontLayer.HttpPort == 0 && conf.FrontLayer.HttpsPort == 0 {
		l4g.Error("No service has started due to configuration. Aborting ...")
		errs <- errors.New("No service started due to configuration.")
	}

	if conf.FrontLayer.HttpPort != 0 && conf.FrontLayer.HttpsPort != 0 {
		if conf.FrontLayer.RedirectHTTPToHTTPS {
			start_https(conf, &errs)
			start_http_with_redirect(conf, &errs)
		} else {
			start_https(conf, &errs)
			start_http_without_redirect(conf, &errs)
		}
	} else {

		if conf.FrontLayer.HttpPort != 0 {
			start_http_without_redirect(conf, &errs)
		}

		if conf.FrontLayer.HttpsPort != 0 {
			start_https(conf, &errs)
		}
	}
	if _conf.FrontLayer.HttpPort != 0 {
		healthcheck.StartHttpHealthCheck(_conf.FrontLayer.HttpPort+1000, &errs)
	}

	l4g.Info("Daemon Server started ...")

	return errs
}

func set_redirector(conf *config.FEConfig) func(w http.ResponseWriter, req *http.Request) {
	return func(w http.ResponseWriter, req *http.Request) {
		http.Redirect(w, req, "https://"+
			fmt.Sprintf("%s:%v", req.Host, conf.FrontLayer.HttpsPort)+req.URL.String(),
			http.StatusMovedPermanently)
	}
}

func start_http_without_redirect(conf *config.FEConfig, errs *chan error) {
	router := router.NewRouter()
	listener, err := net.Listen(conf.FrontLayer.HttpPortProto, fmt.Sprintf(":%v", conf.FrontLayer.HttpPort))

	if err != nil {
		l4g.Error("start_http_without_redirect() err: %v", err.Error())
		*errs <- err
		return
	}

	http_server = &http.Server{
		// 2017/08/16 - RS - Now using a Listener instead (see above).
		// The reason for using a listener is to listen on both IPv6 and IPv4
		// if available.
		//Addr:		 fmt.Sprintf(":%v", conf.FrontLayer.HttpPort),
		Handler: router,

		// RS - 2019/09/10
		// Bug 69434 - FE3 consumes 16GB of ram within 24h
		//
		// We should limit the amount of time used for each request.
		ReadHeaderTimeout: conf.FrontLayer.ReadHeaderTimeout.GetDuration(),
		ReadTimeout:       conf.FrontLayer.ReadTimeout.GetDuration(),
	}

	go func() {
		l4g.Info("Starting HTTP service on %v ...", conf.FrontLayer.HttpPort)

		if err := http_server.Serve(listener); err != nil {
			l4g.Error("start_http_without_redirect() err: %v", err.Error())
			*errs <- err
		}
	}()

}

func start_http_with_redirect(conf *config.FEConfig, errs *chan error) {

	listener, err := net.Listen(conf.FrontLayer.HttpPortProto, fmt.Sprintf(":%v", conf.FrontLayer.HttpPort))

	if err != nil {
		l4g.Error("start_http_without_redirect() err: %v", err.Error())
		*errs <- err
		return
	}

	http_server = &http.Server{
		// 2017/08/16 - RS - Now using a Listener instead (see above).
		// The reason for using a listener is to listen on both IPv6 and IPv4
		// if available.
		//Addr:		 fmt.Sprintf(":%v", conf.FrontLayer.HttpPort),
		Handler: http.HandlerFunc(set_redirector(conf)),

		// RS - 2019/09/10
		// Bug 69434 - FE3 consumes 16GB of ram within 24h
		//
		// We should limit the amount of time used for each request.
		ReadHeaderTimeout: conf.FrontLayer.ReadHeaderTimeout.GetDuration(),
		ReadTimeout:       conf.FrontLayer.ReadTimeout.GetDuration(),
	}

	go func() {
		l4g.Info("Starting HTTP service on %v and redirect to %v ...", conf.FrontLayer.HttpPort, conf.FrontLayer.HttpsPort)
		if err := http_server.Serve(listener); err != nil {
			*errs <- err
		}
	}()

}
func stop_http(conf *config.FEConfig) {
	if https_server != nil {
		if conf != nil {
			l4g.Info("Shutting down HTTPS service on %v ...", conf.FrontLayer.HttpsPort)
		} else {
			l4g.Info("Shutting down HTTPS service!")
		}
		ctx, cancel := context.WithTimeout(context.Background(), SHUTDOWN_TIMEOUT*time.Second)
		_ = cancel
		https_server.Shutdown(ctx)
		l4g.Info("HTTPS service shutdown")
	}

}
func start_https(conf *config.FEConfig, errs *chan error) {
	var err error

	l4g.Info("Starting HTTPS service on %v ...", conf.FrontLayer.HttpsPort)

	router := router.NewRouter()
	// We want to accept any domain name.
	// Restriction will be done inside a dedicated handler.
	//router.Host(conf.FrontLayer.DomainName[0])

	// Load CA Root Certificates
	// Update the _ca_cert_pool global variable
	if err = load_ca_root(conf); err != nil {
		l4g.Error("Aborting due to last error.")
		*errs <- err
		return
	}

	// Load TLS Certificates and Private Keys
	// Update the _tls_ca global variable
	if err = load_tls(conf); err != nil {
		l4g.Error("Aborting due to last error.")
		*errs <- err
		return
	}

	// Load allowed/accepted Cypher suites
	// Update the _cypher_suites variable
	if err = load_cypher_suites(conf); err != nil {
		l4g.Error("Aborting due to last error.")
		*errs <- err
		return
	}

	// Setup HTTPS client
	tlsConfig := &tls.Config{

		// Certificates contains one or more certificate chains
		// to present to the other side of the connection.
		// Server configurations must include at least one certificate
		// or else set GetCertificate.
		Certificates: _tls_ca,

		// ClientCAs defines the set of root certificate authorities
		// that servers use if required to verify a client certificate
		// by the policy in ClientAuth.
		//
		// Not used currently. Only here as a comment for reference.
		//ClientCAs:	  _ca_cert_pool,

		// InsecureSkipVerify controls whether a client verifies the
		// server's certificate chain and host name.
		// If InsecureSkipVerify is true, TLS accepts any certificate
		// presented by the server and any host name in that certificate.
		// In this mode, TLS is susceptible to man-in-the-middle attacks.
		// We purposely set it to false despite we know it is the default.
		InsecureSkipVerify: false,

		// CipherSuites is a list of supported cipher suites. If CipherSuites
		// is nil, TLS uses a list of suites supported by the implementation.
		CipherSuites: _cypher_suites,

		// PreferServerCipherSuites controls whether the server selects the
		// client's most preferred ciphersuite, or the server's most preferred
		// ciphersuite. If true then the server's preference, as expressed in
		// the order of elements in CipherSuites, is used.
		PreferServerCipherSuites: true,

		// MinVersion contains the minimum SSL/TLS version that is acceptable.
		// If zero, then TLS 1.0 is taken as the minimum.
		MinVersion: tls.VersionTLS12,

		// MaxVersion contains the maximum SSL/TLS version that is acceptable.
		// If zero, then the maximum version supported by this package is used,
		// which is currently TLS 1.2.
		MaxVersion: tls.VersionTLS12,
	}

	tlsConfig.BuildNameToCertificate()

	listener, err := net.Listen(conf.FrontLayer.HttpsPortProto, fmt.Sprintf(":%d", conf.FrontLayer.HttpsPort))

	if err != nil {
		l4g.Error("start_http_without_redirect() err: %v", err.Error())
		*errs <- err
		return
	}

	https_server = &http.Server{
		// 2017/08/16 - RS - Now using a Listener instead (see above).
		// The reason for using a listener is to listen on both IPv6 and IPv4
		// if available.
		// Addr:	  fmt.Sprintf(":%d", conf.FrontLayer.HttpsPort),
		TLSConfig: tlsConfig,
		Handler:   router,

		// RS - 2019/09/10
		// Bug 69434 - FE3 consumes 16GB of ram within 24h
		//
		// We should limit the amount of time used for each request.
		ReadHeaderTimeout: conf.FrontLayer.ReadHeaderTimeout.GetDuration(),
		ReadTimeout:       conf.FrontLayer.ReadTimeout.GetDuration(),
	}

	go func() {
		if err := https_server.Serve(listener); err != nil {
			l4g.Error("start_https() err: %v", err.Error())
			*errs <- err
		}
	}()

}

func stop_https(conf *config.FEConfig) {
	l4g.Info("Shutting down HTTPS service on %v ...", conf.FrontLayer.HttpsPort)
	ctx, cancel := context.WithTimeout(context.Background(), SHUTDOWN_TIMEOUT*time.Second)
	_ = cancel
	https_server.Shutdown(ctx)
	l4g.Info("HTTPS service on %v shutdown ...", conf.FrontLayer.HttpsPort)
}
